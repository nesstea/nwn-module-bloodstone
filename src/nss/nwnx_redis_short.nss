// Autogenerated on: 2018-01-21 16:03:23 +0100
#include "nwnx"


// Skipping sub-command: BITFIELD/{"command"=>"OVERFLOW", "type"=>"enum", "enum"=>["WRAP", "SAT", "FAIL"], "optional"=>true} - not supported yet.
// Skipping sub-command: CLIENT_KILL/{"command"=>"TYPE", "type"=>"enum", "enum"=>["normal", "master", "slave", "pubsub"], "optional"=>true} - not supported yet.
/**
 * APPEND
 *
 * Append a value to a key
 *
 * Time complexity: O(1). The amortized time complexity is O(1) assuming the appended value is
 * small and the already present value is of any size, since the dynamic string
 * library used by Redis will double the free space available on every
 * reallocation.
 * Annotated return value: integer
 */
int APPEND(
	string key,
	string value
);

/**
 * AUTH
 *
 * Authenticate to the server
 * Annotated return value: simple-string
 */
string AUTH(
	string password
);

/**
 * BGREWRITEAOF
 *
 * Asynchronously rewrite the append-only file
 * Annotated return value: simple-string
 */
string BGREWRITEAOF();

/**
 * BGSAVE
 *
 * Asynchronously save the dataset to disk
 * Annotated return value: simple-string
 */
string BGSAVE();

/**
 * BITCOUNT
 *
 * Count set bits in a string
 *
 * Time complexity: O(N)
 * Annotated return value: integer
 */
int BITCOUNT(
	string key,
	// Redis type: integer
	int start = 0,
	// Redis type: integer
	int end = 0
);

/**
 * BITFIELD
 *
 * Perform arbitrary bitfield integer operations on strings
 *
 * Time complexity: O(1) for each subcommand specified
 * Annotated return value: 
 */
string BITFIELD(
	string key,
	// Redis type: type
	string get_type = "",
	// Redis type: integer
	int get_offset = 0,
	// Redis type: type
	string set_type = "",
	// Redis type: integer
	int set_offset = 0,
	// Redis type: integer
	int set_value = 0,
	// Redis type: type
	string incrby_type = "",
	// Redis type: integer
	int incrby_offset = 0,
	// Redis type: integer
	int incrby_increment = 0
);

/**
 * BITOP
 *
 * Perform bitwise operations between strings
 *
 * Time complexity: O(N)
 * Annotated return value: integer
 */
int BITOP(
	string operation,
	// Redis type: key
	string destkey,
	string key
);

/**
 * BITPOS
 *
 * Find first bit set or clear in a string
 *
 * Time complexity: O(N)
 * Annotated return value: integer
 */
int BITPOS(
	string key,
	// Redis type: integer
	int bit,
	// Redis type: integer
	int start = 0,
	// Redis type: integer
	int end = 0
);

/**
 * BLPOP
 *
 * Remove and get the first element in a list, or block until one is available
 *
 * Time complexity: O(1)
 * Annotated return value: array
 */
int BLPOP(
	string key,
	// Redis type: integer
	int timeout
);

/**
 * BRPOP
 *
 * Remove and get the last element in a list, or block until one is available
 *
 * Time complexity: O(1)
 * Annotated return value: array
 */
int BRPOP(
	string key,
	// Redis type: integer
	int timeout
);

/**
 * BRPOPLPUSH
 *
 * Pop a value from a list, push it to another list and return it; or block until one is available
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string BRPOPLPUSH(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	// Redis type: integer
	int timeout
);

/**
 * CLIENT_KILL
 *
 * Kill the connection of a client
 *
 * Time complexity: O(N) where N is the number of client connections
 * Annotated return value: simple-string
 */
string CLIENT_KILL(
	string ip_port = "",
	// Redis type: integer
	int id_client_id = 0,
	string addr_ip_port = "",
	string skipme_yes_no = ""
);

/**
 * CLIENT_LIST
 *
 * Get the list of client connections
 *
 * Time complexity: O(N) where N is the number of client connections
 * Annotated return value: bulk-string
 */
string CLIENT_LIST();

/**
 * CLIENT_GETNAME
 *
 * Get the current connection name
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string CLIENT_GETNAME();

/**
 * CLIENT_PAUSE
 *
 * Stop processing commands from clients for some time
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLIENT_PAUSE(
	// Redis type: integer
	int timeout
);

/**
 * CLIENT_REPLY
 *
 * Instruct the server whether to reply to commands
 *
 * Time complexity: O(1)

 * - Valid values for reply_mode: "ON", "OFF", "SKIP"
 * Annotated return value: simple-string
 */
string CLIENT_REPLY(
	// Redis type: enum
	string reply_mode
);

/**
 * CLIENT_SETNAME
 *
 * Set the current connection name
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLIENT_SETNAME(
	string connection_name
);

/**
 * CLUSTER_ADDSLOTS
 *
 * Assign new hash slots to receiving node
 *
 * Time complexity: O(N) where N is the total number of hash slot arguments
 * Annotated return value: simple-string
 */
string CLUSTER_ADDSLOTS(
	// Redis type: integer
	int slot
);

/**
 * CLUSTER_COUNT_FAILURE_REPORTS
 *
 * Return the number of failure reports active for a given node
 *
 * Time complexity: O(N) where N is the number of failure reports
 * Annotated return value: integer
 */
int CLUSTER_COUNT_FAILURE_REPORTS(
	string node_id
);

/**
 * CLUSTER_COUNTKEYSINSLOT
 *
 * Return the number of local keys in the specified hash slot
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int CLUSTER_COUNTKEYSINSLOT(
	// Redis type: integer
	int slot
);

/**
 * CLUSTER_DELSLOTS
 *
 * Set hash slots as unbound in receiving node
 *
 * Time complexity: O(N) where N is the total number of hash slot arguments
 * Annotated return value: simple-string
 */
string CLUSTER_DELSLOTS(
	// Redis type: integer
	int slot
);

/**
 * CLUSTER_FAILOVER
 *
 * Forces a slave to perform a manual failover of its master.
 *
 * Time complexity: O(1)

 * - Valid values for options: "FORCE", "TAKEOVER"
 * Annotated return value: simple-string
 */
string CLUSTER_FAILOVER(
	// Redis type: enum
	string options = ""
);

/**
 * CLUSTER_FORGET
 *
 * Remove a node from the nodes table
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_FORGET(
	string node_id
);

/**
 * CLUSTER_GETKEYSINSLOT
 *
 * Return local key names in the specified hash slot
 *
 * Time complexity: O(log(N)) where N is the number of requested keys
 * Annotated return value: array
 */
int CLUSTER_GETKEYSINSLOT(
	// Redis type: integer
	int slot,
	// Redis type: integer
	int count
);

/**
 * CLUSTER_INFO
 *
 * Provides info about Redis Cluster node state
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string CLUSTER_INFO();

/**
 * CLUSTER_KEYSLOT
 *
 * Returns the hash slot of the specified key
 *
 * Time complexity: O(N) where N is the number of bytes in the key
 * Annotated return value: integer
 */
int CLUSTER_KEYSLOT(
	string key
);

/**
 * CLUSTER_MEET
 *
 * Force a node cluster to handshake with another node
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_MEET(
	string ip,
	// Redis type: integer
	int port
);

/**
 * CLUSTER_NODES
 *
 * Get Cluster config for the node
 *
 * Time complexity: O(N) where N is the total number of Cluster nodes
 * Annotated return value: bulk-string
 */
string CLUSTER_NODES();

/**
 * CLUSTER_REPLICATE
 *
 * Reconfigure a node as a slave of the specified master node
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_REPLICATE(
	string node_id
);

/**
 * CLUSTER_RESET
 *
 * Reset a Redis Cluster node
 *
 * Time complexity: O(N) where N is the number of known nodes. The command may execute a
 * FLUSHALL as a side effect.

 * - Valid values for reset_type: "HARD", "SOFT"
 * Annotated return value: simple-string
 */
string CLUSTER_RESET(
	// Redis type: enum
	string reset_type = ""
);

/**
 * CLUSTER_SAVECONFIG
 *
 * Forces the node to save cluster state on disk
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_SAVECONFIG();

/**
 * CLUSTER_SET_CONFIG_EPOCH
 *
 * Set the configuration epoch in a new node
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CLUSTER_SET_CONFIG_EPOCH(
	// Redis type: integer
	int config_epoch
);

/**
 * CLUSTER_SETSLOT
 *
 * Bind a hash slot to a specific node
 *
 * Time complexity: O(1)

 * - Valid values for subcommand: "IMPORTING", "MIGRATING", "STABLE", "NODE"
 * Annotated return value: simple-string
 */
string CLUSTER_SETSLOT(
	// Redis type: integer
	int slot,
	// Redis type: enum
	string subcommand,
	string node_id = ""
);

/**
 * CLUSTER_SLAVES
 *
 * List slave nodes of the specified master node
 *
 * Time complexity: O(1)
 * Annotated return value: 
 */
string CLUSTER_SLAVES(
	string node_id
);

/**
 * CLUSTER_SLOTS
 *
 * Get array of Cluster slot to node mappings
 *
 * Time complexity: O(N) where N is the total number of Cluster nodes
 * Annotated return value: array
 */
int CLUSTER_SLOTS();

/**
 * COMMAND
 *
 * Get array of Redis command details
 *
 * Time complexity: O(N) where N is the total number of Redis commands
 * Annotated return value: array
 */
int COMMAND();

/**
 * COMMAND_COUNT
 *
 * Get total number of Redis commands
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int COMMAND_COUNT();

/**
 * COMMAND_GETKEYS
 *
 * Extract keys given a full Redis command
 *
 * Time complexity: O(N) where N is the number of arguments to the command
 * Annotated return value: array
 */
int COMMAND_GETKEYS();

/**
 * COMMAND_INFO
 *
 * Get array of specific Redis command details
 *
 * Time complexity: O(N) when N is number of commands to look up
 * Annotated return value: array
 */
int COMMAND_INFO(
	string command_name
);

/**
 * CONFIG_GET
 *
 * Get the value of a configuration parameter
 * Annotated return value: array
 */
int CONFIG_GET(
	string parameter
);

/**
 * CONFIG_REWRITE
 *
 * Rewrite the configuration file with the in memory configuration
 * Annotated return value: simple-string
 */
string CONFIG_REWRITE();

/**
 * CONFIG_SET
 *
 * Set a configuration parameter to the given value
 * Annotated return value: simple-string
 */
string CONFIG_SET(
	string parameter,
	string value
);

/**
 * CONFIG_RESETSTAT
 *
 * Reset the stats returned by INFO
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string CONFIG_RESETSTAT();

/**
 * DBSIZE
 *
 * Return the number of keys in the selected database
 * Annotated return value: integer
 */
int DBSIZE();

/**
 * DEBUG_OBJECT
 *
 * Get debugging information about a key
 * Annotated return value: simple-string
 */
string DEBUG_OBJECT(
	string key
);

/**
 * DEBUG_SEGFAULT
 *
 * Make the server crash
 * Annotated return value: simple-string
 */
string DEBUG_SEGFAULT();

/**
 * DECR
 *
 * Decrement the integer value of a key by one
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int DECR(
	string key
);

/**
 * DECRBY
 *
 * Decrement the integer value of a key by the given number
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int DECRBY(
	string key,
	// Redis type: integer
	int decrement
);

/**
 * DEL
 *
 * Delete a key
 *
 * Time complexity: O(N) where N is the number of keys that will be removed. When a key to
 * remove holds a value other than a string, the individual complexity for this
 * key is O(M) where M is the number of elements in the list, set, sorted set
 * or hash. Removing a single key that holds a string value is O(1).
 * Annotated return value: integer
 */
int DEL(
	string key
);

/**
 * DISCARD
 *
 * Discard all commands issued after MULTI
 * Annotated return value: simple-string
 */
string DISCARD();

/**
 * DUMP
 *
 * Return a serialized version of the value stored at the specified key.
 *
 * Time complexity: O(1) to access the key and additional O(N*M) to serialized it, where N is
 * the number of Redis objects composing the value and M their average size.
 * For small string values the time complexity is thus O(1)+O(1*M) where M is
 * small, so simply O(1).
 * Annotated return value: bulk-string
 */
string DUMP(
	string key
);

/**
 * ECHO
 *
 * Echo the given string
 * Annotated return value: bulk-string
 */
string ECHO(
	string message
);

/**
 * EVAL
 *
 * Execute a Lua script server side
 *
 * Time complexity: Depends on the script that is executed.
 * Annotated return value: 
 */
string EVAL(
	string script,
	// Redis type: integer
	int numkeys,
	string key,
	string arg
);

/**
 * EVALSHA
 *
 * Execute a Lua script server side
 *
 * Time complexity: Depends on the script that is executed.
 * Annotated return value: 
 */
string EVALSHA(
	string sha1,
	// Redis type: integer
	int numkeys,
	string key,
	string arg
);

/**
 * EXEC
 *
 * Execute all commands issued after MULTI
 * Annotated return value: array
 */
int EXEC();

/**
 * EXISTS
 *
 * Determine if a key exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int EXISTS(
	string key
);

/**
 * EXPIRE
 *
 * Set a key's time to live in seconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int EXPIRE(
	string key,
	// Redis type: integer
	int seconds
);

/**
 * EXPIREAT
 *
 * Set the expiration for a key as a UNIX timestamp
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int EXPIREAT(
	string key,
	// Redis type: posix time
	string timestamp
);

/**
 * FLUSHALL
 *
 * Remove all keys from all databases

 * - Valid values for async: "ASYNC"
 * Annotated return value: simple-string
 */
string FLUSHALL(
	// Redis type: enum
	string async = ""
);

/**
 * FLUSHDB
 *
 * Remove all keys from the current database

 * - Valid values for async: "ASYNC"
 * Annotated return value: simple-string
 */
string FLUSHDB(
	// Redis type: enum
	string async = ""
);

/**
 * GEOADD
 *
 * Add one or more geospatial items in the geospatial index represented using a sorted set
 *
 * Time complexity: O(log(N)) for each item added, where N is the number of elements in the
 * sorted set.
 * Annotated return value: integer
 */
int GEOADD(
	string key,
	// Redis type: double
	float longitude,
	// Redis type: double
	float latitude,
	string member
);

/**
 * GEOHASH
 *
 * Returns members of a geospatial index as standard geohash strings
 *
 * Time complexity: O(log(N)) for each member requested, where N is the number of elements in
 * the sorted set.
 * Annotated return value: array
 */
int GEOHASH(
	string key,
	string member
);

/**
 * GEOPOS
 *
 * Returns longitude and latitude of members of a geospatial index
 *
 * Time complexity: O(log(N)) for each member requested, where N is the number of elements in
 * the sorted set.
 * Annotated return value: array
 */
int GEOPOS(
	string key,
	string member
);

/**
 * GEODIST
 *
 * Returns the distance between two members of a geospatial index
 *
 * Time complexity: O(log(N))
 * Annotated return value: bulk-string
 */
string GEODIST(
	string key,
	string member1,
	string member2,
	string unit = ""
);

/**
 * GEORADIUS
 *
 * Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a point
 *
 * Time complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the
 * circular area delimited by center and radius and M is the number of items
 * inside the index.

 * - Valid values for unit: "m", "km", "ft", "mi"

 * - Valid values for withcoord: "WITHCOORD"

 * - Valid values for withdist: "WITHDIST"

 * - Valid values for withhash: "WITHHASH"

 * - Valid values for order: "ASC", "DESC"
 * Annotated return value: array
 */
int GEORADIUS(
	string key,
	// Redis type: double
	float longitude,
	// Redis type: double
	float latitude,
	// Redis type: double
	float radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = "",
	// Redis type: integer
	int count_count = 0,
	// Redis type: enum
	string order = "",
	// Redis type: key
	string store_key = "",
	// Redis type: key
	string storedist_key = ""
);

/**
 * GEORADIUSBYMEMBER
 *
 * Query a sorted set representing a geospatial index to fetch members matching a given maximum distance from a member
 *
 * Time complexity: O(N+log(M)) where N is the number of elements inside the bounding box of the
 * circular area delimited by center and radius and M is the number of items
 * inside the index.

 * - Valid values for unit: "m", "km", "ft", "mi"

 * - Valid values for withcoord: "WITHCOORD"

 * - Valid values for withdist: "WITHDIST"

 * - Valid values for withhash: "WITHHASH"

 * - Valid values for order: "ASC", "DESC"
 * Annotated return value: 
 */
string GEORADIUSBYMEMBER(
	string key,
	string member,
	// Redis type: double
	float radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = "",
	// Redis type: integer
	int count_count = 0,
	// Redis type: enum
	string order = "",
	// Redis type: key
	string store_key = "",
	// Redis type: key
	string storedist_key = ""
);

/**
 * GET
 *
 * Get the value of a key
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string GET(
	string key
);

/**
 * GETBIT
 *
 * Returns the bit value at offset in the string value stored at key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int GETBIT(
	string key,
	// Redis type: integer
	int offset
);

/**
 * GETRANGE
 *
 * Get a substring of the string stored at a key
 *
 * Time complexity: O(N) where N is the length of the returned string. The complexity is
 * ultimately determined by the returned length, but because creating a
 * substring from an existing string is very cheap, it can be considered O(1)
 * for small strings.
 * Annotated return value: bulk-string
 */
string GETRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int end
);

/**
 * GETSET
 *
 * Set the string value of a key and return its old value
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string GETSET(
	string key,
	string value
);

/**
 * HDEL
 *
 * Delete one or more hash fields
 *
 * Time complexity: O(N) where N is the number of fields to be removed.
 * Annotated return value: integer
 */
int HDEL(
	string key,
	string field
);

/**
 * HEXISTS
 *
 * Determine if a hash field exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HEXISTS(
	string key,
	string field
);

/**
 * HGET
 *
 * Get the value of a hash field
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string HGET(
	string key,
	string field
);

/**
 * HGETALL
 *
 * Get all the fields and values in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 * Annotated return value: array
 */
int HGETALL(
	string key
);

/**
 * HINCRBY
 *
 * Increment the integer value of a hash field by the given number
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HINCRBY(
	string key,
	string field,
	// Redis type: integer
	int increment
);

/**
 * HINCRBYFLOAT
 *
 * Increment the float value of a hash field by the given amount
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string HINCRBYFLOAT(
	string key,
	string field,
	// Redis type: double
	float increment
);

/**
 * HKEYS
 *
 * Get all the fields in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 * Annotated return value: array
 */
int HKEYS(
	string key
);

/**
 * HLEN
 *
 * Get the number of fields in a hash
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HLEN(
	string key
);

/**
 * HMGET
 *
 * Get the values of all the given hash fields
 *
 * Time complexity: O(N) where N is the number of fields being requested.
 * Annotated return value: array
 */
int HMGET(
	string key,
	string field
);

/**
 * HMSET
 *
 * Set multiple hash fields to multiple values
 *
 * Time complexity: O(N) where N is the number of fields being set.
 * Annotated return value: simple-string
 */
string HMSET(
	string key,
	string field,
	string value
);

/**
 * HSET
 *
 * Set the string value of a hash field
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HSET(
	string key,
	string field,
	string value
);

/**
 * HSETNX
 *
 * Set the value of a hash field, only if the field does not exist
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HSETNX(
	string key,
	string field,
	string value
);

/**
 * HSTRLEN
 *
 * Get the length of the value of a hash field
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int HSTRLEN(
	string key,
	string field
);

/**
 * HVALS
 *
 * Get all the values in a hash
 *
 * Time complexity: O(N) where N is the size of the hash.
 * Annotated return value: array
 */
int HVALS(
	string key
);

/**
 * INCR
 *
 * Increment the integer value of a key by one
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int INCR(
	string key
);

/**
 * INCRBY
 *
 * Increment the integer value of a key by the given amount
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int INCRBY(
	string key,
	// Redis type: integer
	int increment
);

/**
 * INCRBYFLOAT
 *
 * Increment the float value of a key by the given amount
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string INCRBYFLOAT(
	string key,
	// Redis type: double
	float increment
);

/**
 * INFO
 *
 * Get information and statistics about the server
 * Annotated return value: bulk-string
 */
string INFO(
	string section = ""
);

/**
 * KEYS
 *
 * Find all keys matching the given pattern
 *
 * Time complexity: O(N) with N being the number of keys in the database, under the assumption
 * that the key names in the database and the given pattern have limited
 * length.
 * Annotated return value: array
 */
int KEYS(
	string pattern
);

/**
 * LASTSAVE
 *
 * Get the UNIX time stamp of the last successful save to disk
 * Annotated return value: integer
 */
int LASTSAVE();

/**
 * LINDEX
 *
 * Get an element from a list by its index
 *
 * Time complexity: O(N) where N is the number of elements to traverse to get to the element at
 * index. This makes asking for the first or the last element of the list O(1).
 * Annotated return value: bulk-string
 */
string LINDEX(
	string key,
	// Redis type: integer
	int index
);

/**
 * LINSERT
 *
 * Insert an element before or after another element in a list
 *
 * Time complexity: O(N) where N is the number of elements to traverse before seeing the value
 * pivot. This means that inserting somewhere on the left end on the list
 * (head) can be considered O(1) and inserting somewhere on the right end
 * (tail) is O(N).

 * - Valid values for where: "BEFORE", "AFTER"
 * Annotated return value: integer
 */
int LINSERT(
	string key,
	// Redis type: enum
	string where,
	string pivot,
	string value
);

/**
 * LLEN
 *
 * Get the length of a list
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int LLEN(
	string key
);

/**
 * LPOP
 *
 * Remove and get the first element in a list
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string LPOP(
	string key
);

/**
 * LPUSH
 *
 * Prepend one or multiple values to a list
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int LPUSH(
	string key,
	string value
);

/**
 * LPUSHX
 *
 * Prepend a value to a list, only if the list exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int LPUSHX(
	string key,
	string value
);

/**
 * LRANGE
 *
 * Get a range of elements from a list
 *
 * Time complexity: O(S+N) where S is the distance of start offset from HEAD for small lists,
 * from nearest end (HEAD or TAIL) for large lists; and N is the number of
 * elements in the specified range.
 * Annotated return value: array
 */
int LRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
);

/**
 * LREM
 *
 * Remove elements from a list
 *
 * Time complexity: O(N) where N is the length of the list.
 * Annotated return value: integer
 */
int LREM(
	string key,
	// Redis type: integer
	int count,
	string value
);

/**
 * LSET
 *
 * Set the value of an element in a list by its index
 *
 * Time complexity: O(N) where N is the length of the list. Setting either the first or the last
 * element of the list is O(1).
 * Annotated return value: simple-string
 */
string LSET(
	string key,
	// Redis type: integer
	int index,
	string value
);

/**
 * LTRIM
 *
 * Trim a list to the specified range
 *
 * Time complexity: O(N) where N is the number of elements to be removed by the operation.
 * Annotated return value: simple-string
 */
string LTRIM(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
);

/**
 * MGET
 *
 * Get the values of all the given keys
 *
 * Time complexity: O(N) where N is the number of keys to retrieve.
 * Annotated return value: array
 */
int MGET(
	string key
);

/**
 * MIGRATE
 *
 * Atomically transfer a key from a Redis instance to another one.
 *
 * Time complexity: This command actually executes a DUMP+DEL in the source instance, and a
 * RESTORE in the target instance. See the pages of these commands for time
 * complexity. Also an O(N) data transfer between the two instances is
 * performed.

 * - Valid values for key: "key", "\"\""

 * - Valid values for copy: "COPY"

 * - Valid values for replace: "REPLACE"
 * Annotated return value: simple-string
 */
string MIGRATE(
	string host,
	string port,
	// Redis type: enum
	string key,
	// Redis type: integer
	int destination_db,
	// Redis type: integer
	int timeout,
	// Redis type: enum
	string copy = "",
	// Redis type: enum
	string replace = "",
	// Redis type: key
	string keys_key = ""
);

/**
 * MONITOR
 *
 * Listen for all requests received by the server in real time
 * Annotated return value: 
 */
string MONITOR();

/**
 * MOVE
 *
 * Move a key to another database
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int MOVE(
	string key,
	// Redis type: integer
	int db
);

/**
 * MSET
 *
 * Set multiple keys to multiple values
 *
 * Time complexity: O(N) where N is the number of keys to set.
 * Annotated return value: simple-string
 */
string MSET(
	string key,
	string value
);

/**
 * MSETNX
 *
 * Set multiple keys to multiple values, only if none of the keys exist
 *
 * Time complexity: O(N) where N is the number of keys to set.
 * Annotated return value: integer
 */
int MSETNX(
	string key,
	string value
);

/**
 * MULTI
 *
 * Mark the start of a transaction block
 * Annotated return value: simple-string
 */
string MULTI();

/**
 * OBJECT
 *
 * Inspect the internals of Redis objects
 *
 * Time complexity: O(1) for all the currently implemented subcommands.
 * Annotated return value: 
 */
string OBJECT(
	string subcommand,
	string arguments = ""
);

/**
 * PERSIST
 *
 * Remove the expiration from a key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int PERSIST(
	string key
);

/**
 * PEXPIRE
 *
 * Set a key's time to live in milliseconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int PEXPIRE(
	string key,
	// Redis type: integer
	int milliseconds
);

/**
 * PEXPIREAT
 *
 * Set the expiration for a key as a UNIX timestamp specified in milliseconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int PEXPIREAT(
	string key,
	// Redis type: posix time
	string milliseconds_timestamp
);

/**
 * PFADD
 *
 * Adds the specified elements to the specified HyperLogLog.
 *
 * Time complexity: O(1) to add every element.
 * Annotated return value: integer
 */
int PFADD(
	string key,
	string element
);

/**
 * PFCOUNT
 *
 * Return the approximated cardinality of the set(s) observed by the HyperLogLog at key(s).
 *
 * Time complexity: O(1) with a very small average constant time when called with a single key.
 * O(N) with N being the number of keys, and much bigger constant times, when
 * called with multiple keys.
 * Annotated return value: integer
 */
int PFCOUNT(
	string key
);

/**
 * PFMERGE
 *
 * Merge N different HyperLogLogs into a single one.
 *
 * Time complexity: O(N) to merge N HyperLogLogs, but with high constant times.
 * Annotated return value: simple-string
 */
string PFMERGE(
	// Redis type: key
	string destkey,
	// Redis type: key
	string sourcekey
);

/**
 * PING
 *
 * Ping the server
 * Annotated return value: simple-string
 */
string PING(
	string message = ""
);

/**
 * PSETEX
 *
 * Set the value and expiration in milliseconds of a key
 *
 * Time complexity: O(1)
 * Annotated return value: 
 */
string PSETEX(
	string key,
	// Redis type: integer
	int milliseconds,
	string value
);

/**
 * PUBSUB
 *
 * Inspect the state of the Pub/Sub subsystem
 *
 * Time complexity: O(N) for the CHANNELS subcommand, where N is the number of active channels,
 * and assuming constant time pattern matching (relatively short channels and
 * patterns). O(N) for the NUMSUB subcommand, where N is the number of
 * requested channels. O(1) for the NUMPAT subcommand.
 * Annotated return value: array
 */
int PUBSUB(
	string subcommand,
	string argument = ""
);

/**
 * PTTL
 *
 * Get the time to live for a key in milliseconds
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int PTTL(
	string key
);

/**
 * PUBLISH
 *
 * Post a message to a channel
 *
 * Time complexity: O(N+M) where N is the number of clients subscribed to the receiving channel
 * and M is the total number of subscribed patterns (by any client).
 * Annotated return value: integer
 */
int PUBLISH(
	string channel,
	string message
);

/**
 * QUIT
 *
 * Close the connection
 * Annotated return value: simple-string
 */
string QUIT();

/**
 * RANDOMKEY
 *
 * Return a random key from the keyspace
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string RANDOMKEY();

/**
 * READONLY
 *
 * Enables read queries for a connection to a cluster slave node
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string READONLY();

/**
 * READWRITE
 *
 * Disables read queries for a connection to a cluster slave node
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string READWRITE();

/**
 * RENAME
 *
 * Rename a key
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string RENAME(
	string key,
	// Redis type: key
	string newkey
);

/**
 * RENAMENX
 *
 * Rename a key, only if the new key does not exist
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int RENAMENX(
	string key,
	// Redis type: key
	string newkey
);

/**
 * RESTORE
 *
 * Create a key using the provided serialized value, previously obtained using DUMP.
 *
 * Time complexity: O(1) to create the new key and additional O(N*M) to reconstruct the
 * serialized value, where N is the number of Redis objects composing the value
 * and M their average size. For small string values the time complexity is
 * thus O(1)+O(1*M) where M is small, so simply O(1). However for sorted set
 * values the complexity is O(N*M*log(N)) because inserting values into sorted
 * sets is O(log(N)).

 * - Valid values for replace: "REPLACE"
 * Annotated return value: simple-string
 */
string RESTORE(
	string key,
	// Redis type: integer
	int ttl,
	string serialized_value,
	// Redis type: enum
	string replace = ""
);

/**
 * ROLE
 *
 * Return the role of the instance in the context of replication
 * Annotated return value: array
 */
int ROLE();

/**
 * RPOP
 *
 * Remove and get the last element in a list
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string RPOP(
	string key
);

/**
 * RPOPLPUSH
 *
 * Remove the last element in a list, prepend it to another list and return it
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string RPOPLPUSH(
	// Redis type: key
	string source,
	// Redis type: key
	string destination
);

/**
 * RPUSH
 *
 * Append one or multiple values to a list
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int RPUSH(
	string key,
	string value
);

/**
 * RPUSHX
 *
 * Append a value to a list, only if the list exists
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int RPUSHX(
	string key,
	string value
);

/**
 * SADD
 *
 * Add one or more members to a set
 *
 * Time complexity: O(1) for each element added, so O(N) to add N elements when the command is
 * called with multiple arguments.
 * Annotated return value: integer
 */
int SADD(
	string key,
	string member
);

/**
 * SAVE
 *
 * Synchronously save the dataset to disk
 * Annotated return value: simple-string
 */
string SAVE();

/**
 * SCARD
 *
 * Get the number of members in a set
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int SCARD(
	string key
);

/**
 * SCRIPT_DEBUG
 *
 * Set the debug mode for executed scripts.
 *
 * Time complexity: O(1)

 * - Valid values for mode: "YES", "SYNC", "NO"
 * Annotated return value: simple-string
 */
string SCRIPT_DEBUG(
	// Redis type: enum
	string mode
);

/**
 * SCRIPT_EXISTS
 *
 * Check existence of scripts in the script cache.
 *
 * Time complexity: O(N) with N being the number of scripts to check (so checking a single
 * script is an O(1) operation).
 * Annotated return value: array
 */
int SCRIPT_EXISTS(
	string sha1
);

/**
 * SCRIPT_FLUSH
 *
 * Remove all the scripts from the script cache.
 *
 * Time complexity: O(N) with N being the number of scripts in cache
 * Annotated return value: simple-string
 */
string SCRIPT_FLUSH();

/**
 * SCRIPT_KILL
 *
 * Kill the script currently in execution.
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string SCRIPT_KILL();

/**
 * SCRIPT_LOAD
 *
 * Load the specified Lua script into the script cache.
 *
 * Time complexity: O(N) with N being the length in bytes of the script body.
 * Annotated return value: bulk-string
 */
string SCRIPT_LOAD(
	string script
);

/**
 * SDIFF
 *
 * Subtract multiple sets
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: array
 */
int SDIFF(
	string key
);

/**
 * SDIFFSTORE
 *
 * Subtract multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: integer
 */
int SDIFFSTORE(
	// Redis type: key
	string destination,
	string key
);

/**
 * SELECT
 *
 * Change the selected database for the current connection
 * Annotated return value: simple-string
 */
string SELECT(
	// Redis type: integer
	int index
);

/**
 * SET
 *
 * Set the string value of a key
 *
 * Time complexity: O(1)

 * - Valid values for condition: "NX", "XX"
 * Annotated return value: simple-string
 */
string SET(
	string key,
	string value,
	// Redis type: integer
	int ex_seconds = 0,
	// Redis type: integer
	int px_milliseconds = 0,
	// Redis type: enum
	string condition = ""
);

/**
 * SETBIT
 *
 * Sets or clears the bit at offset in the string value stored at key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int SETBIT(
	string key,
	// Redis type: integer
	int offset,
	string value
);

/**
 * SETEX
 *
 * Set the value and expiration of a key
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string SETEX(
	string key,
	// Redis type: integer
	int seconds,
	string value
);

/**
 * SETNX
 *
 * Set the value of a key, only if the key does not exist
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int SETNX(
	string key,
	string value
);

/**
 * SETRANGE
 *
 * Overwrite part of a string at key starting at the specified offset
 *
 * Time complexity: O(1), not counting the time taken to copy the new string in place. Usually,
 * this string is very small so the amortized complexity is O(1). Otherwise,
 * complexity is O(M) with M being the length of the value argument.
 * Annotated return value: integer
 */
int SETRANGE(
	string key,
	// Redis type: integer
	int offset,
	string value
);

/**
 * SHUTDOWN
 *
 * Synchronously save the dataset to disk and then shut down the server

 * - Valid values for save_mode: "NOSAVE", "SAVE"
 * Annotated return value: simple-string
 */
string SHUTDOWN(
	// Redis type: enum
	string save_mode = ""
);

/**
 * SINTER
 *
 * Intersect multiple sets
 *
 * Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is
 * the number of sets.
 * Annotated return value: array
 */
int SINTER(
	string key
);

/**
 * SINTERSTORE
 *
 * Intersect multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N*M) worst case where N is the cardinality of the smallest set and M is
 * the number of sets.
 * Annotated return value: integer
 */
int SINTERSTORE(
	// Redis type: key
	string destination,
	string key
);

/**
 * SISMEMBER
 *
 * Determine if a given value is a member of a set
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int SISMEMBER(
	string key,
	string member
);

/**
 * SLAVEOF
 *
 * Make the server a slave of another instance, or promote it as master
 * Annotated return value: simple-string
 */
string SLAVEOF(
	string host,
	string port
);

/**
 * SLOWLOG
 *
 * Manages the Redis slow queries log
 * Annotated return value: 
 */
string SLOWLOG(
	string subcommand,
	string argument = ""
);

/**
 * SMEMBERS
 *
 * Get all the members in a set
 *
 * Time complexity: O(N) where N is the set cardinality.
 * Annotated return value: array
 */
int SMEMBERS(
	string key
);

/**
 * SMOVE
 *
 * Move a member from one set to another
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int SMOVE(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	string member
);

/**
 * SORT
 *
 * Sort the elements in a list, set or sorted set
 *
 * Time complexity: O(N+M*log(M)) where N is the number of elements in the list or set to sort,
 * and M the number of returned elements. When the elements are not sorted,
 * complexity is currently O(N) as there is a copy step that will be avoided in
 * next releases.

 * - Valid values for order: "ASC", "DESC"

 * - Valid values for sorting: "ALPHA"
 * Annotated return value: array
 */
int SORT(
	string key,
	// Redis type: pattern
	string by_pattern = "",
	// Redis type: integer
	int limit_offset = 0,
	// Redis type: integer
	int limit_count = 0,
	string get_pattern = "",
	// Redis type: enum
	string order = "",
	// Redis type: enum
	string sorting = "",
	// Redis type: key
	string store_destination = ""
);

/**
 * SPOP
 *
 * Remove and return one or multiple random members from a set
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string SPOP(
	string key,
	// Redis type: integer
	int count = 0
);

/**
 * SRANDMEMBER
 *
 * Get one or multiple random members from a set
 *
 * Time complexity: Without the count argument O(1), otherwise O(N) where N is the absolute
 * value of the passed count.
 * Annotated return value: bulk-string
 */
string SRANDMEMBER(
	string key,
	// Redis type: integer
	int count = 0
);

/**
 * SREM
 *
 * Remove one or more members from a set
 *
 * Time complexity: O(N) where N is the number of members to be removed.
 * Annotated return value: integer
 */
int SREM(
	string key,
	string member
);

/**
 * STRLEN
 *
 * Get the length of the value stored in a key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int STRLEN(
	string key
);

/**
 * SUNION
 *
 * Add multiple sets
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: array
 */
int SUNION(
	string key
);

/**
 * SUNIONSTORE
 *
 * Add multiple sets and store the resulting set in a key
 *
 * Time complexity: O(N) where N is the total number of elements in all given sets.
 * Annotated return value: integer
 */
int SUNIONSTORE(
	// Redis type: key
	string destination,
	string key
);

/**
 * SWAPDB
 *
 * Swaps two Redis databases
 * Annotated return value: simple-string
 */
string SWAPDB(
	// Redis type: integer
	int index,
	// Redis type: integer
	int index_1
);

/**
 * SYNC
 *
 * Internal command used for replication
 * Annotated return value: 
 */
string SYNC();

/**
 * TIME
 *
 * Return the current server time
 *
 * Time complexity: O(1)
 * Annotated return value: array
 */
int TIME();

/**
 * TOUCH
 *
 * Alters the last access time of a key(s). Returns the number of existing keys specified.
 *
 * Time complexity: O(N) where N is the number of keys that will be touched.
 * Annotated return value: integer
 */
int TOUCH(
	string key
);

/**
 * TTL
 *
 * Get the time to live for a key
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int TTL(
	string key
);

/**
 * TYPE
 *
 * Determine the type stored at key
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string TYPE(
	string key
);

/**
 * UNLINK
 *
 * Delete a key asynchronously in another thread. Otherwise it is just as DEL, but non blocking.
 *
 * Time complexity: O(1) for each key removed regardless of its size. Then the command does O(N)
 * work in a different thread in order to reclaim memory, where N is the number
 * of allocations the deleted objects where composed of.
 * Annotated return value: integer
 */
int UNLINK(
	string key
);

/**
 * UNWATCH
 *
 * Forget about all watched keys
 *
 * Time complexity: O(1)
 * Annotated return value: simple-string
 */
string UNWATCH();

/**
 * WAIT
 *
 * Wait for the synchronous replication of all the write commands sent in the context of the current connection
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int WAIT(
	// Redis type: integer
	int numslaves,
	// Redis type: integer
	int timeout
);

/**
 * WATCH
 *
 * Watch the given keys to determine execution of the MULTI/EXEC block
 *
 * Time complexity: O(1) for every key.
 * Annotated return value: simple-string
 */
string WATCH(
	string key
);

/**
 * ZADD
 *
 * Add one or more members to a sorted set, or update its score if it already exists
 *
 * Time complexity: O(log(N)) for each item added, where N is the number of elements in the
 * sorted set.

 * - Valid values for condition: "NX", "XX"

 * - Valid values for change: "CH"

 * - Valid values for increment: "INCR"
 * Annotated return value: integer
 */
int ZADD(
	string key,
	// Redis type: enum
	string condition = "",
	// Redis type: enum
	string change = "",
	// Redis type: enum
	string increment = "",
	// Redis type: double
	float score = 0.0,
	string member = ""
);

/**
 * ZCARD
 *
 * Get the number of members in a sorted set
 *
 * Time complexity: O(1)
 * Annotated return value: integer
 */
int ZCARD(
	string key
);

/**
 * ZCOUNT
 *
 * Count the members in a sorted set with scores within the given values
 *
 * Time complexity: O(log(N)) with N being the number of elements in the sorted set.
 * Annotated return value: integer
 */
int ZCOUNT(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max
);

/**
 * ZINCRBY
 *
 * Increment the score of a member in a sorted set
 *
 * Time complexity: O(log(N)) where N is the number of elements in the sorted set.
 * Annotated return value: bulk-string
 */
string ZINCRBY(
	string key,
	// Redis type: integer
	int increment,
	string member
);

/**
 * ZINTERSTORE
 *
 * Intersect multiple sorted sets and store the resulting sorted set in a new key
 *
 * Time complexity: O(N*K)+O(M*log(M)) worst case with N being the smallest input sorted set, K
 * being the number of input sorted sets and M being the number of elements in
 * the resulting sorted set.

 * - Valid values for aggregate_aggregate: "SUM", "MIN", "MAX"
 * Annotated return value: integer
 */
int ZINTERSTORE(
	// Redis type: key
	string destination,
	// Redis type: integer
	int numkeys,
	string key,
	// Redis type: integer
	int weights_weight = 0,
	// Redis type: enum
	string aggregate_aggregate = ""
);

/**
 * ZLEXCOUNT
 *
 * Count the number of members in a sorted set between a given lexicographical range
 *
 * Time complexity: O(log(N)) with N being the number of elements in the sorted set.
 * Annotated return value: integer
 */
int ZLEXCOUNT(
	string key,
	string min,
	string max
);

/**
 * ZRANGE
 *
 * Return a range of members in a sorted set, by index
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements returned.

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
int ZRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop,
	// Redis type: enum
	string withscores = ""
);

/**
 * ZRANGEBYLEX
 *
 * Return a range of members in a sorted set, by lexicographical range
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).
 * Annotated return value: array
 */
int ZRANGEBYLEX(
	string key,
	string min,
	string max,
	// Redis type: integer
	int limit_offset = 0,
	// Redis type: integer
	int limit_count = 0
);

/**
 * ZREVRANGEBYLEX
 *
 * Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).
 * Annotated return value: array
 */
int ZREVRANGEBYLEX(
	string key,
	string max,
	string min,
	// Redis type: integer
	int limit_offset = 0,
	// Redis type: integer
	int limit_count = 0
);

/**
 * ZRANGEBYSCORE
 *
 * Return a range of members in a sorted set, by score
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
int ZRANGEBYSCORE(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	int limit_offset = 0,
	// Redis type: integer
	int limit_count = 0
);

/**
 * ZRANK
 *
 * Determine the index of a member in a sorted set
 *
 * Time complexity: O(log(N))
 * Annotated return value: integer
 */
int ZRANK(
	string key,
	string member
);

/**
 * ZREM
 *
 * Remove one or more members from a sorted set
 *
 * Time complexity: O(M*log(N)) with N being the number of elements in the sorted set and M the
 * number of elements to be removed.
 * Annotated return value: integer
 */
int ZREM(
	string key,
	string member
);

/**
 * ZREMRANGEBYLEX
 *
 * Remove all members in a sorted set between the given lexicographical range
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements removed by the operation.
 * Annotated return value: integer
 */
int ZREMRANGEBYLEX(
	string key,
	string min,
	string max
);

/**
 * ZREMRANGEBYRANK
 *
 * Remove all members in a sorted set within the given indexes
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements removed by the operation.
 * Annotated return value: integer
 */
int ZREMRANGEBYRANK(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
);

/**
 * ZREMRANGEBYSCORE
 *
 * Remove all members in a sorted set within the given scores
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements removed by the operation.
 * Annotated return value: integer
 */
int ZREMRANGEBYSCORE(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max
);

/**
 * ZREVRANGE
 *
 * Return a range of members in a sorted set, by index, with scores ordered from high to low
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements returned.

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
int ZREVRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop,
	// Redis type: enum
	string withscores = ""
);

/**
 * ZREVRANGEBYSCORE
 *
 * Return a range of members in a sorted set, by score, with scores ordered from high to low
 *
 * Time complexity: O(log(N)+M) with N being the number of elements in the sorted set and M the
 * number of elements being returned. If M is constant (e.g. always asking for
 * the first 10 elements with LIMIT), you can consider it O(log(N)).

 * - Valid values for withscores: "WITHSCORES"
 * Annotated return value: array
 */
int ZREVRANGEBYSCORE(
	string key,
	// Redis type: double
	float max,
	// Redis type: double
	float min,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	int limit_offset = 0,
	// Redis type: integer
	int limit_count = 0
);

/**
 * ZREVRANK
 *
 * Determine the index of a member in a sorted set, with scores ordered from high to low
 *
 * Time complexity: O(log(N))
 * Annotated return value: integer
 */
int ZREVRANK(
	string key,
	string member
);

/**
 * ZSCORE
 *
 * Get the score associated with the given member in a sorted set
 *
 * Time complexity: O(1)
 * Annotated return value: bulk-string
 */
string ZSCORE(
	string key,
	string member
);

/**
 * ZUNIONSTORE
 *
 * Add multiple sorted sets and store the resulting sorted set in a new key
 *
 * Time complexity: O(N)+O(M log(M)) with N being the sum of the sizes of the input sorted sets,
 * and M being the number of elements in the resulting sorted set.

 * - Valid values for aggregate_aggregate: "SUM", "MIN", "MAX"
 * Annotated return value: integer
 */
int ZUNIONSTORE(
	// Redis type: key
	string destination,
	// Redis type: integer
	int numkeys,
	string key,
	// Redis type: integer
	int weights_weight = 0,
	// Redis type: enum
	string aggregate_aggregate = ""
);

/**
 * SCAN
 *
 * Incrementally iterate the keys space
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection.
 * Annotated return value: 
 */
string SCAN(
	// Redis type: integer
	int cursor,
	// Redis type: pattern
	string match_pattern = "",
	// Redis type: integer
	int count_count = 0
);

/**
 * SSCAN
 *
 * Incrementally iterate Set elements
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection..
 * Annotated return value: 
 */
string SSCAN(
	string key,
	// Redis type: integer
	int cursor,
	// Redis type: pattern
	string match_pattern = "",
	// Redis type: integer
	int count_count = 0
);

/**
 * HSCAN
 *
 * Incrementally iterate hash fields and associated values
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection..
 * Annotated return value: 
 */
string HSCAN(
	string key,
	// Redis type: integer
	int cursor,
	// Redis type: pattern
	string match_pattern = "",
	// Redis type: integer
	int count_count = 0
);

/**
 * ZSCAN
 *
 * Incrementally iterate sorted sets elements and associated scores
 *
 * Time complexity: O(1) for every call. O(N) for a complete iteration, including enough command
 * calls for the cursor to return back to 0. N is the number of elements inside
 * the collection..
 * Annotated return value: 
 */
string ZSCAN(
	string key,
	// Redis type: integer
	int cursor,
	// Redis type: pattern
	string match_pattern = "",
	// Redis type: integer
	int count_count = 0
);



// Implementation below
int APPEND(
	string key,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "APPEND");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string AUTH(
	string password
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "AUTH");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", password);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string BGREWRITEAOF() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "BGREWRITEAOF");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string BGSAVE() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "BGSAVE");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int BITCOUNT(
	string key,
	// Redis type: integer
	int start = 0,
	// Redis type: integer
	int end = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "BITCOUNT");
  if (end != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(end));
  if (start != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(start));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string BITFIELD(
	string key,
	// Redis type: type
	string get_type = "",
	// Redis type: integer
	int get_offset = 0,
	// Redis type: type
	string set_type = "",
	// Redis type: integer
	int set_offset = 0,
	// Redis type: integer
	int set_value = 0,
	// Redis type: type
	string incrby_type = "",
	// Redis type: integer
	int incrby_offset = 0,
	// Redis type: integer
	int incrby_increment = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "BITFIELD");
  if (incrby_increment != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(incrby_increment));
  if (incrby_offset != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(incrby_offset));
  if (incrby_type != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", incrby_type);
  if (set_value != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(set_value));
  if (set_offset != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(set_offset));
  if (set_type != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", set_type);
  if (get_offset != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(get_offset));
  if (get_type != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", get_type);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int BITOP(
	string operation,
	// Redis type: key
	string destkey,
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "BITOP");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", destkey);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", operation);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int BITPOS(
	string key,
	// Redis type: integer
	int bit,
	// Redis type: integer
	int start = 0,
	// Redis type: integer
	int end = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "BITPOS");
  if (end != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(end));
  if (start != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(start));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(bit));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int BLPOP(
	string key,
	// Redis type: integer
	int timeout
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "BLPOP");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(timeout));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int BRPOP(
	string key,
	// Redis type: integer
	int timeout
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "BRPOP");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(timeout));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string BRPOPLPUSH(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	// Redis type: integer
	int timeout
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "BRPOPLPUSH");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(timeout));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", destination);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", source);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLIENT_KILL(
	string ip_port = "",
	// Redis type: integer
	int id_client_id = 0,
	string addr_ip_port = "",
	string skipme_yes_no = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLIENT_KILL");
  if (skipme_yes_no != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", skipme_yes_no);
  if (addr_ip_port != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", addr_ip_port);
  if (id_client_id != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(id_client_id));
  if (ip_port != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", ip_port);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLIENT_LIST() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLIENT_LIST");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLIENT_GETNAME() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLIENT_GETNAME");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLIENT_PAUSE(
	// Redis type: integer
	int timeout
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLIENT_PAUSE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(timeout));
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLIENT_REPLY(
	// Redis type: enum
	string reply_mode
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLIENT_REPLY");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", reply_mode);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLIENT_SETNAME(
	string connection_name
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLIENT_SETNAME");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", connection_name);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLUSTER_ADDSLOTS(
	// Redis type: integer
	int slot
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_ADDSLOTS");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(slot));
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int CLUSTER_COUNT_FAILURE_REPORTS(
	string node_id
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_COUNT_FAILURE_REPORTS");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", node_id);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int CLUSTER_COUNTKEYSINSLOT(
	// Redis type: integer
	int slot
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_COUNTKEYSINSLOT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(slot));
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string CLUSTER_DELSLOTS(
	// Redis type: integer
	int slot
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_DELSLOTS");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(slot));
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLUSTER_FAILOVER(
	// Redis type: enum
	string options = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_FAILOVER");
  if (options != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", options);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLUSTER_FORGET(
	string node_id
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_FORGET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", node_id);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int CLUSTER_GETKEYSINSLOT(
	// Redis type: integer
	int slot,
	// Redis type: integer
	int count
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_GETKEYSINSLOT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(count));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(slot));
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string CLUSTER_INFO() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_INFO");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int CLUSTER_KEYSLOT(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_KEYSLOT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string CLUSTER_MEET(
	string ip,
	// Redis type: integer
	int port
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_MEET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(port));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", ip);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLUSTER_NODES() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_NODES");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLUSTER_REPLICATE(
	string node_id
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_REPLICATE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", node_id);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLUSTER_RESET(
	// Redis type: enum
	string reset_type = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_RESET");
  if (reset_type != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", reset_type);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLUSTER_SAVECONFIG() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_SAVECONFIG");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLUSTER_SET_CONFIG_EPOCH(
	// Redis type: integer
	int config_epoch
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_SET_CONFIG_EPOCH");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(config_epoch));
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLUSTER_SETSLOT(
	// Redis type: integer
	int slot,
	// Redis type: enum
	string subcommand,
	string node_id = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_SETSLOT");
  if (node_id != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", node_id);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", subcommand);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(slot));
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CLUSTER_SLAVES(
	string node_id
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_SLAVES");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", node_id);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int CLUSTER_SLOTS() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CLUSTER_SLOTS");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int COMMAND() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "COMMAND");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int COMMAND_COUNT() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "COMMAND_COUNT");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int COMMAND_GETKEYS() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "COMMAND_GETKEYS");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int COMMAND_INFO(
	string command_name
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "COMMAND_INFO");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", command_name);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int CONFIG_GET(
	string parameter
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CONFIG_GET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", parameter);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string CONFIG_REWRITE() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CONFIG_REWRITE");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CONFIG_SET(
	string parameter,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CONFIG_SET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", parameter);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string CONFIG_RESETSTAT() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "CONFIG_RESETSTAT");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int DBSIZE() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "DBSIZE");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string DEBUG_OBJECT(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "DEBUG_OBJECT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string DEBUG_SEGFAULT() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "DEBUG_SEGFAULT");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int DECR(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "DECR");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int DECRBY(
	string key,
	// Redis type: integer
	int decrement
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "DECRBY");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(decrement));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int DEL(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "DEL");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string DISCARD() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "DISCARD");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string DUMP(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "DUMP");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string ECHO(
	string message
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ECHO");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", message);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string EVAL(
	string script,
	// Redis type: integer
	int numkeys,
	string key,
	string arg
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "EVAL");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", arg);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(numkeys));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", script);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string EVALSHA(
	string sha1,
	// Redis type: integer
	int numkeys,
	string key,
	string arg
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "EVALSHA");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", arg);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(numkeys));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", sha1);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int EXEC() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "EXEC");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int EXISTS(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "EXISTS");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int EXPIRE(
	string key,
	// Redis type: integer
	int seconds
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "EXPIRE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(seconds));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int EXPIREAT(
	string key,
	// Redis type: posix time
	string timestamp
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "EXPIREAT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", timestamp);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string FLUSHALL(
	// Redis type: enum
	string async = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "FLUSHALL");
  if (async != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", async);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string FLUSHDB(
	// Redis type: enum
	string async = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "FLUSHDB");
  if (async != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", async);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int GEOADD(
	string key,
	// Redis type: double
	float longitude,
	// Redis type: double
	float latitude,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "GEOADD");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(latitude, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(longitude, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int GEOHASH(
	string key,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "GEOHASH");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int GEOPOS(
	string key,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "GEOPOS");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string GEODIST(
	string key,
	string member1,
	string member2,
	string unit = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "GEODIST");
  if (unit != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", unit);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member2);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member1);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int GEORADIUS(
	string key,
	// Redis type: double
	float longitude,
	// Redis type: double
	float latitude,
	// Redis type: double
	float radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = "",
	// Redis type: integer
	int count_count = 0,
	// Redis type: enum
	string order = "",
	// Redis type: key
	string store_key = "",
	// Redis type: key
	string storedist_key = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "GEORADIUS");
  if (storedist_key != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", storedist_key);
  if (store_key != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", store_key);
  if (order != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", order);
  if (count_count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(count_count));
  if (withhash != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", withhash);
  if (withdist != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", withdist);
  if (withcoord != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", withcoord);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", unit);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(radius, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(latitude, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(longitude, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string GEORADIUSBYMEMBER(
	string key,
	string member,
	// Redis type: double
	float radius,
	// Redis type: enum
	string unit,
	// Redis type: enum
	string withcoord = "",
	// Redis type: enum
	string withdist = "",
	// Redis type: enum
	string withhash = "",
	// Redis type: integer
	int count_count = 0,
	// Redis type: enum
	string order = "",
	// Redis type: key
	string store_key = "",
	// Redis type: key
	string storedist_key = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "GEORADIUSBYMEMBER");
  if (storedist_key != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", storedist_key);
  if (store_key != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", store_key);
  if (order != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", order);
  if (count_count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(count_count));
  if (withhash != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", withhash);
  if (withdist != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", withdist);
  if (withcoord != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", withcoord);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", unit);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(radius, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string GET(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "GET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int GETBIT(
	string key,
	// Redis type: integer
	int offset
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "GETBIT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(offset));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string GETRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int end
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "GETRANGE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(end));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(start));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string GETSET(
	string key,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "GETSET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int HDEL(
	string key,
	string field
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HDEL");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", field);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int HEXISTS(
	string key,
	string field
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HEXISTS");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", field);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string HGET(
	string key,
	string field
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HGET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", field);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int HGETALL(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HGETALL");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int HINCRBY(
	string key,
	string field,
	// Redis type: integer
	int increment
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HINCRBY");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(increment));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", field);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string HINCRBYFLOAT(
	string key,
	string field,
	// Redis type: double
	float increment
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HINCRBYFLOAT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(increment, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", field);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int HKEYS(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HKEYS");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int HLEN(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HLEN");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int HMGET(
	string key,
	string field
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HMGET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", field);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string HMSET(
	string key,
	string field,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HMSET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", field);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int HSET(
	string key,
	string field,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HSET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", field);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int HSETNX(
	string key,
	string field,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HSETNX");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", field);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int HSTRLEN(
	string key,
	string field
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HSTRLEN");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", field);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int HVALS(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HVALS");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int INCR(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "INCR");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int INCRBY(
	string key,
	// Redis type: integer
	int increment
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "INCRBY");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(increment));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string INCRBYFLOAT(
	string key,
	// Redis type: double
	float increment
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "INCRBYFLOAT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(increment, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string INFO(
	string section = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "INFO");
  if (section != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", section);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int KEYS(
	string pattern
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "KEYS");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", pattern);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int LASTSAVE() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "LASTSAVE");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string LINDEX(
	string key,
	// Redis type: integer
	int index
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "LINDEX");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(index));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int LINSERT(
	string key,
	// Redis type: enum
	string where,
	string pivot,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "LINSERT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", pivot);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", where);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int LLEN(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "LLEN");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string LPOP(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "LPOP");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int LPUSH(
	string key,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "LPUSH");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int LPUSHX(
	string key,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "LPUSHX");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int LRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "LRANGE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(stop));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(start));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int LREM(
	string key,
	// Redis type: integer
	int count,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "LREM");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(count));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string LSET(
	string key,
	// Redis type: integer
	int index,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "LSET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(index));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string LTRIM(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "LTRIM");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(stop));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(start));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int MGET(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "MGET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string MIGRATE(
	string host,
	string port,
	// Redis type: enum
	string key,
	// Redis type: integer
	int destination_db,
	// Redis type: integer
	int timeout,
	// Redis type: enum
	string copy = "",
	// Redis type: enum
	string replace = "",
	// Redis type: key
	string keys_key = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "MIGRATE");
  if (keys_key != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", keys_key);
  if (replace != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", replace);
  if (copy != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", copy);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(timeout));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(destination_db));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", port);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", host);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string MONITOR() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "MONITOR");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int MOVE(
	string key,
	// Redis type: integer
	int db
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "MOVE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(db));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string MSET(
	string key,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "MSET");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int MSETNX(
	string key,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "MSETNX");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string MULTI() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "MULTI");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string OBJECT(
	string subcommand,
	string arguments = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "OBJECT");
  if (arguments != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", arguments);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", subcommand);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int PERSIST(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "PERSIST");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int PEXPIRE(
	string key,
	// Redis type: integer
	int milliseconds
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "PEXPIRE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(milliseconds));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int PEXPIREAT(
	string key,
	// Redis type: posix time
	string milliseconds_timestamp
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "PEXPIREAT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", milliseconds_timestamp);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int PFADD(
	string key,
	string element
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "PFADD");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", element);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int PFCOUNT(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "PFCOUNT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string PFMERGE(
	// Redis type: key
	string destkey,
	// Redis type: key
	string sourcekey
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "PFMERGE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", sourcekey);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", destkey);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string PING(
	string message = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "PING");
  if (message != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", message);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string PSETEX(
	string key,
	// Redis type: integer
	int milliseconds,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "PSETEX");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(milliseconds));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int PUBSUB(
	string subcommand,
	string argument = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "PUBSUB");
  if (argument != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", argument);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", subcommand);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int PTTL(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "PTTL");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int PUBLISH(
	string channel,
	string message
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "PUBLISH");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", message);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", channel);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string QUIT() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "QUIT");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string RANDOMKEY() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "RANDOMKEY");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string READONLY() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "READONLY");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string READWRITE() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "READWRITE");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string RENAME(
	string key,
	// Redis type: key
	string newkey
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "RENAME");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", newkey);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int RENAMENX(
	string key,
	// Redis type: key
	string newkey
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "RENAMENX");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", newkey);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string RESTORE(
	string key,
	// Redis type: integer
	int ttl,
	string serialized_value,
	// Redis type: enum
	string replace = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "RESTORE");
  if (replace != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", replace);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", serialized_value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(ttl));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int ROLE() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ROLE");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string RPOP(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "RPOP");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string RPOPLPUSH(
	// Redis type: key
	string source,
	// Redis type: key
	string destination
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "RPOPLPUSH");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", destination);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", source);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int RPUSH(
	string key,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "RPUSH");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int RPUSHX(
	string key,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "RPUSHX");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int SADD(
	string key,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SADD");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string SAVE() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SAVE");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int SCARD(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SCARD");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string SCRIPT_DEBUG(
	// Redis type: enum
	string mode
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SCRIPT_DEBUG");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", mode);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int SCRIPT_EXISTS(
	string sha1
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SCRIPT_EXISTS");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", sha1);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string SCRIPT_FLUSH() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SCRIPT_FLUSH");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string SCRIPT_KILL() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SCRIPT_KILL");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string SCRIPT_LOAD(
	string script
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SCRIPT_LOAD");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", script);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int SDIFF(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SDIFF");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int SDIFFSTORE(
	// Redis type: key
	string destination,
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SDIFFSTORE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", destination);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string SELECT(
	// Redis type: integer
	int index
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SELECT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(index));
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string SET(
	string key,
	string value,
	// Redis type: integer
	int ex_seconds = 0,
	// Redis type: integer
	int px_milliseconds = 0,
	// Redis type: enum
	string condition = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SET");
  if (condition != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", condition);
  if (px_milliseconds != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(px_milliseconds));
  if (ex_seconds != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(ex_seconds));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int SETBIT(
	string key,
	// Redis type: integer
	int offset,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SETBIT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(offset));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string SETEX(
	string key,
	// Redis type: integer
	int seconds,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SETEX");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(seconds));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int SETNX(
	string key,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SETNX");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int SETRANGE(
	string key,
	// Redis type: integer
	int offset,
	string value
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SETRANGE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", value);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(offset));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string SHUTDOWN(
	// Redis type: enum
	string save_mode = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SHUTDOWN");
  if (save_mode != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", save_mode);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int SINTER(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SINTER");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int SINTERSTORE(
	// Redis type: key
	string destination,
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SINTERSTORE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", destination);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int SISMEMBER(
	string key,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SISMEMBER");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string SLAVEOF(
	string host,
	string port
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SLAVEOF");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", port);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", host);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string SLOWLOG(
	string subcommand,
	string argument = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SLOWLOG");
  if (argument != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", argument);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", subcommand);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int SMEMBERS(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SMEMBERS");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int SMOVE(
	// Redis type: key
	string source,
	// Redis type: key
	string destination,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SMOVE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", destination);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", source);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int SORT(
	string key,
	// Redis type: pattern
	string by_pattern = "",
	// Redis type: integer
	int limit_offset = 0,
	// Redis type: integer
	int limit_count = 0,
	string get_pattern = "",
	// Redis type: enum
	string order = "",
	// Redis type: enum
	string sorting = "",
	// Redis type: key
	string store_destination = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SORT");
  if (store_destination != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", store_destination);
  if (sorting != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", sorting);
  if (order != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", order);
  if (get_pattern != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", get_pattern);
  if (limit_count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(limit_count));
  if (limit_offset != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(limit_offset));
  if (by_pattern != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", by_pattern);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string SPOP(
	string key,
	// Redis type: integer
	int count = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SPOP");
  if (count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(count));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string SRANDMEMBER(
	string key,
	// Redis type: integer
	int count = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SRANDMEMBER");
  if (count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(count));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int SREM(
	string key,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SREM");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int STRLEN(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "STRLEN");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int SUNION(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SUNION");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int SUNIONSTORE(
	// Redis type: key
	string destination,
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SUNIONSTORE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", destination);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string SWAPDB(
	// Redis type: integer
	int index,
	// Redis type: integer
	int index_1
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SWAPDB");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(index_1));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(index));
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string SYNC() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SYNC");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int TIME() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "TIME");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int TOUCH(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "TOUCH");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int TTL(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "TTL");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string TYPE(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "TYPE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int UNLINK(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "UNLINK");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string UNWATCH() {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "UNWATCH");
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int WAIT(
	// Redis type: integer
	int numslaves,
	// Redis type: integer
	int timeout
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "WAIT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(timeout));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(numslaves));
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string WATCH(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "WATCH");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int ZADD(
	string key,
	// Redis type: enum
	string condition = "",
	// Redis type: enum
	string change = "",
	// Redis type: enum
	string increment = "",
	// Redis type: double
	float score = 0.0,
	string member = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZADD");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(score, 0));
  if (increment != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", increment);
  if (change != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", change);
  if (condition != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", condition);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZCARD(
	string key
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZCARD");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZCOUNT(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZCOUNT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(max, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(min, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string ZINCRBY(
	string key,
	// Redis type: integer
	int increment,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZINCRBY");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(increment));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int ZINTERSTORE(
	// Redis type: key
	string destination,
	// Redis type: integer
	int numkeys,
	string key,
	// Redis type: integer
	int weights_weight = 0,
	// Redis type: enum
	string aggregate_aggregate = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZINTERSTORE");
  if (aggregate_aggregate != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", aggregate_aggregate);
  if (weights_weight != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(weights_weight));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(numkeys));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", destination);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZLEXCOUNT(
	string key,
	string min,
	string max
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZLEXCOUNT");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", max);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", min);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop,
	// Redis type: enum
	string withscores = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZRANGE");
  if (withscores != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", withscores);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(stop));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(start));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZRANGEBYLEX(
	string key,
	string min,
	string max,
	// Redis type: integer
	int limit_offset = 0,
	// Redis type: integer
	int limit_count = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZRANGEBYLEX");
  if (limit_count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(limit_count));
  if (limit_offset != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(limit_offset));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", max);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", min);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZREVRANGEBYLEX(
	string key,
	string max,
	string min,
	// Redis type: integer
	int limit_offset = 0,
	// Redis type: integer
	int limit_count = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZREVRANGEBYLEX");
  if (limit_count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(limit_count));
  if (limit_offset != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(limit_offset));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", min);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", max);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZRANGEBYSCORE(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	int limit_offset = 0,
	// Redis type: integer
	int limit_count = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZRANGEBYSCORE");
  if (limit_count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(limit_count));
  if (limit_offset != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(limit_offset));
  if (withscores != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", withscores);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(max, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(min, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZRANK(
	string key,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZRANK");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZREM(
	string key,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZREM");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZREMRANGEBYLEX(
	string key,
	string min,
	string max
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZREMRANGEBYLEX");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", max);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", min);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZREMRANGEBYRANK(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZREMRANGEBYRANK");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(stop));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(start));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZREMRANGEBYSCORE(
	string key,
	// Redis type: double
	float min,
	// Redis type: double
	float max
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZREMRANGEBYSCORE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(max, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(min, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZREVRANGE(
	string key,
	// Redis type: integer
	int start,
	// Redis type: integer
	int stop,
	// Redis type: enum
	string withscores = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZREVRANGE");
  if (withscores != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", withscores);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(stop));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(start));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZREVRANGEBYSCORE(
	string key,
	// Redis type: double
	float max,
	// Redis type: double
	float min,
	// Redis type: enum
	string withscores = "",
	// Redis type: integer
	int limit_offset = 0,
	// Redis type: integer
	int limit_count = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZREVRANGEBYSCORE");
  if (limit_count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(limit_count));
  if (limit_offset != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(limit_offset));
  if (withscores != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", withscores);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(min, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", FloatToString(max, 0));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

int ZREVRANK(
	string key,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZREVRANK");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string ZSCORE(
	string key,
	string member
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZSCORE");
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", member);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

int ZUNIONSTORE(
	// Redis type: key
	string destination,
	// Redis type: integer
	int numkeys,
	string key,
	// Redis type: integer
	int weights_weight = 0,
	// Redis type: enum
	string aggregate_aggregate = ""
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZUNIONSTORE");
  if (aggregate_aggregate != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", aggregate_aggregate);
  if (weights_weight != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(weights_weight));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(numkeys));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", destination);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return StringToInt(NWNX_GetReturnValueString("NWNX_Redis", "RawCommand"));
}

string SCAN(
	// Redis type: integer
	int cursor,
	// Redis type: pattern
	string match_pattern = "",
	// Redis type: integer
	int count_count = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SCAN");
  if (count_count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(count_count));
  if (match_pattern != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", match_pattern);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(cursor));
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string SSCAN(
	string key,
	// Redis type: integer
	int cursor,
	// Redis type: pattern
	string match_pattern = "",
	// Redis type: integer
	int count_count = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "SSCAN");
  if (count_count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(count_count));
  if (match_pattern != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", match_pattern);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(cursor));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string HSCAN(
	string key,
	// Redis type: integer
	int cursor,
	// Redis type: pattern
	string match_pattern = "",
	// Redis type: integer
	int count_count = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "HSCAN");
  if (count_count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(count_count));
  if (match_pattern != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", match_pattern);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(cursor));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

string ZSCAN(
	string key,
	// Redis type: integer
	int cursor,
	// Redis type: pattern
	string match_pattern = "",
	// Redis type: integer
	int count_count = 0
) {
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", "ZSCAN");
  if (count_count != 0) NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(count_count));
  if (match_pattern != "") NWNX_PushArgumentString("NWNX_Redis", "RawCommand", match_pattern);
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", IntToString(cursor));
  NWNX_PushArgumentString("NWNX_Redis", "RawCommand", key);
  NWNX_CallFunction("NWNX_Redis", "RawCommand");
  return NWNX_GetReturnValueString("NWNX_Redis", "RawCommand");
}

